import type { ModuleOptions } from '../module'

export async function useUserSession({ options }: {
  options: {
    moduleOptions: ModuleOptions
    configs: any
  }
}) {
  return [
    'import { createAuthClient } from \'better-auth/vue\'',
    ...options.configs.map((config: any) => {
      return `import ${config.key} from "${config.path}"`
    }),
    'import { defu } from \'defu\'',
    'import { computed, ref } from \'vue\'',
    'import { navigateTo, useRequestHeaders, useRequestURL, useRuntimeConfig, useState } from \'#app\'',
    '',
    'let _authInstance',
    '',
    'export function createAuthInstance() {',
    '  const url = useRequestURL()',
    '  const headers = import.meta.server ? useRequestHeaders() : undefined',
    '  const config = useRuntimeConfig()',
    '',
    '  const authClient = createAuthClient({',
    '    baseURL: url.origin,',
    ...options.moduleOptions.options.client
      ? Object.entries(options.moduleOptions.options.client).map(([key, value]) => {
          return `    ${key}: ${JSON.stringify(value)},`
        })
      : [],
    '    fetchOptions: {',
    ...options.configs.map((config: any) => {
      return `    ...${config.key}?.fetchOptions || {},`
    }),
    '      headers,',
    '    },',
    ...options.configs.map((config: any) => {
      return `    ${config.key},`
    }),
    '   plugins: [',
    ...options.configs.map((config: any) => {
      return `    ...${config.key}?.plugins || [],`
    }),
    ' ],',
    '  })',
    '',
    '  const options = defu(config.public.betterAuth.redirectOptions || {}, {',
    '    redirectUserTo: \'/profile\',',
    '    redirectGuestTo: \'/signin\',',
    '    redirectUnauthorizedTo: \'/401\',',
    '  })',
    '',
    '  const session = useState(\'auth:session\', () => null)',
    '  const user = useState(\'auth:user\', () => null)',
    '  const sessionFetching = import.meta.server ? ref(false) : useState(\'auth:sessionFetching\', () => false)',
    '',
    '  const fetchSession = async () => {',
    '    if (sessionFetching.value) {',
    '      return',
    '    }',
    '    sessionFetching.value = true',
    '    const { data } = await authClient.getSession({',
    '      fetchOptions: {',
    '        headers,',
    '      },',
    '    })',
    '    session.value = data?.session || null',
    '    user.value = data?.user || null',
    '    sessionFetching.value = false',
    '    return data',
    '  }',
    '',
    '  return {',
    '    session,',
    '    user,',
    '    loggedIn: computed(() => !!session.value),',
    '    signIn: authClient.signIn,',
    '    signUp: authClient.signUp,',
    '    options,',
    '    fetchSession,',
    '    client: authClient,',
    '    signOut: async (options = {}) => {',
    '      try {',
    '        await authClient.signOut()',
    '        if (options.redirectTo)',
    '          await navigateTo(options.redirectTo)',
    '      }',
    '      catch (error) {',
    '        console.error(\'Sign out failed:\', error)',
    '        throw error',
    '      }',
    '    },',
    '  }',
    '}',
    '',
    '// Setup session listener for client-side updates',
    'function setupSessionListener(client) {',
    '  if (!import.meta.client)',
    '    return',
    '',
    '  client.$store.listen(\'$sessionSignal\', async (signal) => {',
    '    if (!signal)',
    '      return',
    '    await client.useSession($fetch)',
    '  })',
    '}',
    '',
    'export function useUserSession() {',
    '  if (_authInstance && import.meta.client)',
    '    return _authInstance',
    '',
    '  const auth = createAuthInstance()',
    '',
    '  if (import.meta.client) {',
    '    setupSessionListener(auth.client)',
    '    _authInstance = auth',
    '  }',
    '',
    '  return auth',
    '}',
    '',
  ].join('\n')
}
